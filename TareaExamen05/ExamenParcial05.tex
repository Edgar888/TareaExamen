\documentclass{article}
\usepackage{tikz}
\usetikzlibrary{arrows.meta, positioning}

\usepackage[utf8]{inputenc}
\usepackage[spanish,mexico]{babel}
\usepackage{listings}
\usepackage{amsmath}
\setlength{\textwidth}{18cm}
\setlength{\oddsidemargin}{-1cm}
\setlength{\headsep}{1cm}
\setlength{\voffset}{0cm}
\setlength{\topmargin}{0cm}
\setlength{\headheight}{0cm}
\usepackage{tikz}
\usepackage{semantic}
\usepackage{url}
\usetikzlibrary{positioning}
\usetikzlibrary{calc,arrows}
\usepackage{multicol}
\usepackage{lipsum} 
\usepackage{multirow}
\usepackage{amssymb}

\usepackage{graphicx}
\usepackage{forest}
\usepackage{tikz-qtree}
\usepackage{xcolor}

\begin{document}
\pagecolor{black}
\color{white}

%%%%%% ENCABEZADO %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \colorbox{black}{
        \begin{minipage}[t]{0.16 \textwidth}
           \begin{flushright}
            \includegraphics[width=1in]{UNAM.png}
           \end{flushright}
        \end{minipage}
        \begin{minipage}[H]{0.62 \textwidth}
            \begin{center}
                {\large \textsc{Universdad Nacional Autónoma de México}}
                \vspace{0.25cm}
                \\
                { \large \textbf{Lenguajes de Programacion\\ Examen Parcial V}}                
                \textbf{}
                \begin{multicols}{2}
                \begin{flushleft}
                \begin{itemize}
                    % NOMBRES DE INTEGRANTES
                    \item  \small Edgar Montiel Ledesma\\ 317317794
    
                    \item \footnotesize Carlos Daniel Cortes Jimenez\\ 420004846
                \end{itemize}
                \end{flushleft}
                \vspace{0.25cm}
                \end{multicols} 
            \end{center}
            \vspace{0.05cm}
        \end{minipage}
        \begin{minipage}[t]{0.16 \textwidth}
            \begin{flushleft}
                \includegraphics[width=1in]{EFC.png}
            \end{flushleft}
        \end{minipage}
    }
    
    \begin{tikzpicture}
        \draw[thick] (-6.5,0)--(11.2,0);
    \end{tikzpicture}
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \begin{itemize}
        \item[1.] Sean A, B, C, D, E con la siguiente relacion de subtipado:
        \begin{center}
            \begin{itemize}
                \item[ ] E $\leq$ B
                \item[ ] D $\leq$ B
                \item[ ] B $\leq$ A
                \item[ ] C $\leq$ A 
            \end{itemize}
        \end{center}

        Para los siguientes subtipados diga si son validos o no. En caso de ser validos, muestre la derivacion formal, en caso de ser invalidos, añada una sola regla que la haga valida y haga la derivacion formal.

        \begin{itemize}
            \item[a)] ((A $+$ B) $\rightarrow$ \{y : E, x : D\}) $+$ ((A $×$ A) $\rightarrow$ E) $\leq$ ((A $+$ B) $\rightarrow$ \{x : C\}) $+$ ((A × B) $\rightarrow$ C)

            \begin{center}
                \begin{itemize}
                    \item Esta expresión es válida, y la derivación formal es la siguiente:
                    \item[ ] ((A+B)→\{y:E,x:D\})+((A×A)→E)\\ $\leq$ ((A+B)→\{x:C\})+((A×B)→C)
                    \item Por regla de subtipado:
                    \item[ ] (A+B)→\{y:E,x:D\}$\leq$(A+B)→\{x:C\}
                    \item Por regla de subtipado:
                    \item[ ] (A×A)→E$\leq$(A×B)→C
                    \item Por reglas de subtipado anteriores:
                    \item[ ] A$\leq$B(de B$\leq$A)
                    \item Por regla de subtipado:
                    \item[ ] A×A$\leq$A×B
                    \item Por reglas de subtipado anteriores:
                    \item[ ] E$\leq$B(de B$\leq$A)
                    \item Por regla de subtipado:
                    \item[ ] (A×A)→E$\leq$(A×B)→C
                    \item Por regla de subtipado:
                    \item[ ] (A+B)→\{y:E,x:D\}+(A×A)→E\\ $\leq$(A+B)→\{x:C\}+(A×B)→C
                \end{itemize}
            \end{center}
 


            \item[b)] (E × D × A $\rightarrow$ \{x : A\}) $\rightarrow$ C $\leq$ (B × A $\rightarrow$ \{x : A, y : D\}) $\rightarrow$  A\\
            Esta expresión no es inválida. Para hacerla válida, agregaremos la regla de subtipado A$\leq$C. 
            \begin{itemize}
                \item La derivación formal es la siguiente:
                \item[ ] (E×D×A→\{x:A\})→C\\ $\leq$(B×A→\{x:A,y:D\})→A
                \item Por regla de subtipado:
                \item[ ] E×D×A→\{x:A\}$\leq$B×A→\{x:A,y:D\}
                \item Por reglas de subtipado anteriores:
                \item[ ] A$\leq$C(nueva regla agregada)
                \item Por regla de subtipado:
                \item[ ] E×D×A→\{x:A\}$\leq$B×A→\{x:A,y:D\}
                \item Por regla de subtipado:
                \item[ ] (E×D×A→\{x:A\})→C$\leq$(B×A→\{x:A,y:D\})→A
            \end{itemize}            
            Ahora, con la adición de la regla A$\leq$C, la expresión se vuelve válida. 
        \end{itemize}
    \end{itemize}

    \begin{itemize}
        \item[2.] Considera los tipos Rectangulo parametrizado por la altura y el ancho y Cuadrado parametrizado por el tamaño de uno de los lados.

        \begin{itemize}
            \item[a)] Define los tipos anteriores mediante tipos suma y producto.
            \item[b)] ¿Que relacion de subtipado existe entre estos tipos? es decir ¿cual de estos es el subtipo y cual el supertipo? justifica tu respuesta, una forma de justificar la respuesta es explicar como serıa el proceso de coercion entre el subtipo y el supertipo.
            \item[c)] De acuerdo a la relacion de subtipado del inciso anterior, ordena los siguientes tipos funcion:
            \begin{center}
                \begin{itemize}
                     \item[ ] Rectangulo $\rightarrow$ Rectangulo
                     \item[ ] Rectangulo $\rightarrow$ Cuadrado
                     \item[ ] Cuadrado $\rightarrow$ Rectangulo
                     \item[ ] Cuadrado $\rightarrow$ Cuadrado 
                 \end{itemize}
            \end{center} 
        \end{itemize}
    \end{itemize}

    \begin{itemize}
        \item[3.] El objetivo de este ejercicio es definir el siguiente mini lenguaje de expresiones aritmeticas y booleanas MinEAB en JPP:
        \begin{center}
            \center $e$ ::= $n$ $|$ $true$ $|$ $false$ $|$ $e$ + $e$ $|$ $e$ $<$ $e$
        \end{center}

        Se busca que se sigan los siguientes puntos.

        \begin{itemize}
            \item[a)] Defina una clase Expr que incluya los siguientes metodos:
                \begin{itemize}
                    \item isAtom que devuelve true si la expresion no tiene subexpresiones propias.
                    \item lsub que devuelve la subexpresion izquierda de una expresion no atomica.
                    \item rsub que devuelve la subexpresion derecha de una expresion no atomica.
                    \item eval que devuelve el valor de la expresion.
                \end{itemize}
            Esta clase debe ser abstracta en el sentido de que no tiene atributos y por lo tanto sus metodos no hacen nada pero deben ser definidos. Es decir, se considera a Expr como una interfaz.\\

            Primero definimos lo siguiente:\\

            // Clase que representa los valores del lenguaje (Nat + Bool)\\
            abstract class Value\{\}\\

            // Clase para representar valores naturales\\
            class Nat extends Value\{\\
            \hspace*{0.6cm}int value;\\

            \hspace*{0.6cm}Nat(int value)\{\\
            \hspace*{1.2cm}this.value = value;\\
            \hspace*{0.6cm}\}\\
            \}\\

            // Clase para representar valores booleanos\\
            class Bool extends Value\{\\
            \hspace*{0.6cm}boolean value;\\

            \hspace*{0.6cm}Bool(boolean value)\{\\
            \hspace*{1.2cm}this.value = value;\\
            \hspace*{0.6cm}\}\\
            \}\\

            La interfaz Expr es la siguiente:\\

            // Interfaz que representa expresiones del lenguaje MinEAB\\
            abstract class Expr \{\\
            \hspace*{0.65cm}abstract boolean isAtom();\\
            \hspace*{0.65cm}abstract Expr lsub();\\
            \hspace*{0.65cm}abstract Expr rsub();\\
            \hspace*{0.65cm}abstract Value eval();\\
            \}\\

            \item[b)] Defina una clase NumExpr que extienda a Expr y de forma que sus instancias correspondan a numeros.\\

            // Clase que representa expresiones que son números en el lenguaje MinEAB
            class NumExpr extends Expr\{\\
            \hspace*{0.6cm}private int value;\\
            
            \hspace*{0.6cm}NumExpr(int value)\{\\
            \hspace*{1.37cm}this.value = value;\\
            \hspace*{0.65cm}\}\\
            
            \hspace*{0.6cm}boolean isAtom()\{\\
            \hspace*{1.37cm}return true;\\
            \hspace*{0.6cm}\}\\
            
            \hspace*{0.6cm}Expr lsub()\{\\
            \hspace*{1.37cm}return null;\\
            \hspace*{0.6cm}\}\\
            
            \hspace*{0.6cm}Expr rsub()\{\\
            \hspace*{1.37cm}return null;\\
            \hspace*{0.6cm}\}\\
            
            \hspace*{0.6cm}Value eval()\{\\
            \hspace*{1.37cm}return new Value(value);\\
            \hspace*{0.6cm}\}\\
            \}\\
            
            \item[c)] Defina una clase BoolExpr que extienda a Expr y de forma que sus instancias correspondan a booleanos.\\

            // Clase que representa expresiones que son booleanos en el lenguaje MinEAB\\
            class BoolExpr extends Expr\{\\
            \hspace*{0.6cm}private boolean value;\\
            
            \hspace*{0.6cm}BoolExpr(boolean value)\{\\
            \hspace*{1.37cm}this.value = value;\\
            \hspace*{0.65cm}\}\\
            
            \hspace*{0.6cm}boolean isAtom()\{\\
            \hspace*{1.37cm}return true;\\
            \hspace*{0.6cm}\}\\
            
            \hspace*{0.6cm}Expr lsub()\{\\
            \hspace*{1.37cm}return null;\\
            \hspace*{0.6cm}\}\\
            
            \hspace*{0.6cm}Expr rsub()\{\\
            \hspace*{1.37cm}return null;\\
            \hspace*{0.6cm}\}\\
            
            \hspace*{0.6cm}Value eval()\{\\
            \hspace*{1.37cm}return new Bool(value);\\
            \hspace*{0.6cm}\}\\
            \}\\
            
            \item[d)] Defina una clase SumExpr que extienda a Expr y de forma que sus instancias correspondan a sumas.\\

            // Clase que representa expresiones que son sumas en el lenguaje MinEAB\\
            class SumExpr extends Expr\{\\
            \hspace*{0.6cm}private Expr left;\\
            \hspace*{0.6cm}private Expr right;\\
            
            \hspace*{0.6cm}SumExpr(Expr left, Expr right)\{\\
            \hspace*{1.37cm}this.left = left;\\
            \hspace*{1.37cm}this.right = right;\\
            \hspace*{0.65cm}\}\\
            
            \hspace*{0.6cm}boolean isAtom()\{\\
            \hspace*{1.37cm}return false;\\
            \hspace*{0.6cm}\}\\
            
            \hspace*{0.6cm}Expr lsub()\{\\
            \hspace*{1.37cm}return left;\\
            \hspace*{0.6cm}\}\\
            
            \hspace*{0.6cm}Expr rsub()\{\\
            \hspace*{1.37cm}return right;\\
            \hspace*{0.6cm}\}\\
            
            \hspace*{0.6cm}Value eval()\{\\
            \hspace*{1.37cm}Value leftValue = left.eval();\\
            \hspace*{1.37cm}Value rightValue = right.eval();\\
            \hspace*{1.37cm}// Evalúa las subexpresiones y realiza la suma si ambos valores son números naturales\\
            \hspace*{1.37cm}if (leftValue Nat \&\& rightValue Nat )\{\\
            \hspace*{1.97cm}int suma = ((Nat) leftValue).value +  ((Nat) rightValue).value;\\
            \hspace*{1.97cm}return new Nat(suma);\\
            \hspace*{1.37cm}\} else \{\\
            \hspace*{1.97cm}return null;\\
            \hspace*{1.37cm}\}\\
            \hspace*{0.6cm}\}\\
            \}\\
            
            \item[e)] Defina una clase LTExpr que extienda a Expr y de forma que sus instancias correspondan a comparaciones de orden.\\

            // Clase que representa expresiones que son comparaciones de orden menor que en el lenguaje MinEAB\\
            class LTExpr extends Expr\{\\
            \hspace*{0.6cm}private Expr left;\\
            \hspace*{0.6cm}private Expr right;\\
            
            \hspace*{0.6cm}LTExpr(Expr left, Expr right)\{\\
            \hspace*{1.37cm}this.left = left;\\
            \hspace*{1.37cm}this.right = right;\\
            \hspace*{0.65cm}\}\\
            
            \hspace*{0.6cm}boolean isAtom()\{\\
            \hspace*{1.37cm}return false;\\
            \hspace*{0.6cm}\}\\
            
            \hspace*{0.6cm}Expr lsub()\{\\
            \hspace*{1.37cm}return left;\\
            \hspace*{0.6cm}\}\\
            
            \hspace*{0.6cm}Expr rsub()\{\\
            \hspace*{1.37cm}return right;\\
            \hspace*{0.6cm}\}\\
            
            \hspace*{0.6cm}Value eval()\{\\
            \hspace*{1.37cm}Value leftValue = left.eval();\\
            \hspace*{1.37cm}Value rightValue = right.eval();\\
            \hspace*{1.37cm}// Evalúa las subexpresiones y realiza la comparación si ambos valores son números naturales\\
            \hspace*{1.37cm}if (leftValue Nat \&\& rightValue Nat )\{\\
            \hspace*{1.97cm}int leftVal = ((Nat) leftValue).value;\\
            \hspace*{1.97cm}int rightVal = ((Nat) rightValue).value;\\
            \hspace*{1.97cm}boolean resultado = leftVal $<$ rightVal;\\
            \hspace*{1.97cm}return new Bool(resultado);\\
            \hspace*{1.37cm}\} else \{\\
            \hspace*{1.97cm}return null;\\
            \hspace*{1.37cm}\}\\
            \hspace*{0.6cm}\}\\
            \}\\
            
            \item[f)] De ejemplos de instancias de cada una de las clases.\\
            
            Puede suponer definida una clase Value cuyas instancias sean los valores del lenguaje, ya sea naturales o booleanos. Es decir, Value es esencialmente el tipo Nat + Bool. Ademas de otras clases primitivas con los metodos que requiera, especificandolos previamente. Tambien puede utilizar convenientemente la constante de error en cualquier metodo.\\

            \begin{enumerate}
                \item[1.-] Instancia para NumExpr:\\
                \begin{itemize}
                    \item Expr numExpr = new NumExpr(21);\\
                \end{itemize}

                \item[2.-] Instancia para BoolExpr:\\
                \begin{itemize}
                    \item Expr boolExpr = new BoolExpr(false);\\
                \end{itemize}

                \item[3.-] Instancia para SumExpr:\\
                \begin{itemize}
                    \item Expr sumExpr = new SumExpr(new NumExpr(11), new NumExpr(32));\\
                \end{itemize}

                \item[4.-] Instancia para LTExpr:\\
                \begin{itemize}
                    \item Expr ltExpr = new LTExpr(new NumExpr(23), new NumExpr(30));\\
                \end{itemize}
            \end{enumerate}
            
        \end{itemize}
    \end{itemize}
\end{document}
