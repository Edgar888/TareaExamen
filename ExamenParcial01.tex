\documentclass{article}
\usepackage{tikz}
\usetikzlibrary{arrows.meta, positioning}

\usepackage[utf8]{inputenc}
\usepackage[spanish,mexico]{babel}
\usepackage{listings}
\usepackage{amsmath}
\setlength{\textwidth}{18cm}
\setlength{\oddsidemargin}{-1cm}
\setlength{\headsep}{-1cm}
\setlength{\voffset}{0cm}
\setlength{\topmargin}{0cm}
\setlength{\headheight}{0cm}
\usepackage{tikz}
\usetikzlibrary{positioning}
\usetikzlibrary{calc,arrows}
\usepackage{multicol}
\usepackage{lipsum} 

\usepackage{amsmath}

\usepackage{graphicx}
\usepackage{forest}
\usepackage{tikz-qtree}
\usepackage{xcolor}

\begin{document}
\pagecolor{black}
\color{white}

%%%%%% ENCABEZADO %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \colorbox{black}{
        \begin{minipage}[t]{0.16 \textwidth}
           \begin{flushright}
            \includegraphics[width=1in]{UNAM.png}
           \end{flushright}
        \end{minipage}
        \begin{minipage}[H]{0.62 \textwidth}
            \begin{center}
                {\large \textsc{Universdad Nacional Autónoma de México}}
                \vspace{0.25cm}
                \\
                { \large \textbf{Lenguajes de Programacion\\ Examen Parcial I}}                
                \textbf{}
                \begin{multicols}{2}
                \begin{flushleft}
                \begin{itemize}
                    % NOMBRES DE INTEGRANTES
                    \item  \small Edgar Montiel Ledesma\\ 317317794
    
                    \item \footnotesize Carlos Daniel Cortes Jimenez\\ 420004846
                \end{itemize}
                \end{flushleft}
                \vspace{0.25cm}
                \end{multicols} 
            \end{center}
            \vspace{0.05cm}
        \end{minipage}
        \begin{minipage}[t]{0.16 \textwidth}
            \begin{flushleft}
                \includegraphics[width=1in]{EFC.png}
            \end{flushleft}
        \end{minipage}
    }
    
    \begin{tikzpicture}
        \draw[thick] (-6.5,0)--(11.2,0);
    \end{tikzpicture}
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \begin{itemize}
        \item[1.] En el lenguaje de programacion Zoo, los nombres para variables deben empezar con el caracter ’V’ seguido por una cadena cualquiera no vacıa de caracteres ’o’ o ’z’.
            \begin{itemize}
                \item[a)]Defina un juicio ozv tal que s ozv se cumpla si y solo si s es un nombre valido de variable en Zoo.\\
                ozv(s) $\Leftrightarrow$ (s comienza con V) $\land$ (s contiene al menos un o $\lor$ z despues de V)\\
                Donde:\\
                \begin{itemize}
                    \item s representa la cadena que se esta evaluando.
                    \item $\Leftrightarrow$ "si y solo si"
                    \item (s comienza con V) es verdadero si el primer carácter de la cadena s es V.
                    \item (s contiene al menos un o $\lor$ z despues de V) es verdadero si la cadena s contiene al menos un carácter o $\lor$ z después del primer caracter V.
                \end{itemize}
                Teniendo la siginete gramatica
                \begin{center}
                    \begin{itemize}
                        \item[ ] $E ::= Vs$
                        \item[ ] $s ::= os \,|\, zs \,|\, o \,|\, z $  
                    \end{itemize}
                \end{center}

                \begin{align*}
                    \frac{P}{Q} & \text{(Premisa)} \\
                    \frac{Q \Rightarrow R}{R} & \text{(Premisa)}\\
                    &\rule{2cm}{0.1pt}&\\
                    \frac{P}{R}&\text{(Modus Ponens)}
                \end{align*}

                \item[b)] Derive V ozo ozv usando sus reglas.
                \item[c)] Enuncie el principio de induccion estructural para el juicio ozv y utilicelo para demostrar que: si w ozv entonces $\exists u \in {o, z}+ (w = V u)$\\

                Si w = "V", entonces $\exists$u $\in$ o, z (w = V u).\\

                Paso de la inducción: Supongamos que tenemos una cadena w que es un nombre válido de variable en el lenguaje Zoo, es decir, ozv(w) es verdadero. Queremos demostrar que para cualquier cadena más compleja w\' que se pueda formar al agregar un carácter \'o\' o \'z\' al final de w, la propiedad sigue siendo verdadera. Entonces, consideremos dos casos:\\

                Caso 1: Si agregamos \'o\' al final de w para formar w\', entonces podemos decir que w\' = w \'o\'. Dado que w ya es un nombre válido de variable, podemos tomar u igual a w y todavía se cumplirá la propiedad:\\

                Si w\' = w \'o\', entonces $\exists$u $\in$ o, z (w\' = V u).\\

                Caso 2: Podemos decir que w' = w 'z' si agregamos "z" al final de w para formar w'. Dado que w ya es un nombre válido de variable, podemos tomar u igual a w y aún se cumplirá la propiedad:\\ 

                Si w\' = w \'z\', entonces $\exists$u $\in$ o, z (w\' = V u).\\

                En ambos casos demostramos que si la propiedad es verdadera para w, también es verdadera para w', donde w' se construye agregando "o" o "z" al final de w.\\

                Por lo tanto la propiedad es verdadera para todas las cadenas w, que son nombres de variable válidos en el lenguaje Zoo.
            \end{itemize} 
        \item[2.] En muchos lenguajes de programacion las expresiones flotantes incluyen el uso de notacion cientıfica. Por ejemplo\\
        en Pascal la notacion cientıfica se expresa usando una letra e. Por ejemplo $+9.67$e$-15$ significa $9.67$ × $10-15$ y las expresiones flotantes son de alguna de las siguientes tres formas:
            \begin{center}
                s.u s e r s.u e r
            \end{center}
        donde s, r son enteros signados y u es un entero no signado.
            \begin{itemize}
                \item[a)] Defina un juicio pfloat que genere a las expresiones flotantes de Pascal. Observe que debe tambien definir juicios para enteros signados y no signados.
                \item[b)] Utilice su definicion para dar una derivacion de $+9.67$e$-15$.
            \end{itemize}
        Sugerencia: siempre es util definir primero una gramatica libre de contexto adecuada y transformarla en el juicio deseado.

        \item[3.] Un proceso estandar en la implementacion de compiladores es el llamado plegado de constantes (constant folding) que consiste en reconocer y evaluar expresiones constantes en tiempo de compilacion en vez de computar los resultados en tiempo de ejecucin, esto incluye simplificaciones usando propiedades aritmeticas. Por ejemplo la expresion $(2+3+y)*(x+4*5)$ se simplifica a $(5 + y)*(x + 20)$, la expresion $2 * x + 0$ se simplifica en $2 * x$ y la expresion $1 * (x + 2 * z)$ se simplifica en $x + 2 * z$. Considere el siguiente lenguaje EAs de expresiones aritmeticas simples.
            \begin{center}
                $e ::= x | n | e + e | -e | e * e | (e)$
            \end{center}
    
            \begin{itemize}
                \item[a)] Defina una funcion $cfold :: EAs \rightarrow EAs$ que realize el proceso de plegado de constantes. Puede utilizar pseudocodigo de Haskell.

                \begin{lstlisting}[language=Haskell]

                cfold :: EAs -> EAs
                cfold (x) = x
                cfold (n) = n
                cfold (e1 + e2) | isNumber e1 && isNumber e2 = e1 + e2
                                | otherwise = cfold e1 + cfold e2
                cfold (-e) | isNumber e = -e
                           | otherwise = -cfold e
                cfold (e1 * e2) | isNumber e1 && isNumber e2 = e1 * e2
                                | otherwise = cfold e1 * cfold e2
                cfold (e) = e

                isNumber :: EAs -> Bool
                isNumber (n) = True
                isNumber (_) = False
                
                \end{lstlisting}

                \item[b)] Verifique que su definicion es correcta mediante el computo de $cfold((5 + 2) + x * 1)$

                Verificamos que la definicion de $cfold$ es correcta:\\
                Evaluamos primero $cfold((5 + 2)$ $\rightarrow$ $cfold(7)$ dado que 7 es una constante se simplifica a 7.\\

                Ahora evealuamos $cfold(x * 1)$ $\rightarrow$ $cfold(x)$ ya que 1 es una constante, y al multiplicar por 1 obtendremos el mismo valor por lo que la expresión se simplifica a solo $x$.\\

                Por lo que el resultado de aplicar $cfold$ a $(5 + 2) + x * 1$ es $7 + x$.\\
                
                \item[c)] Defina el interprete denotativo para EAs y demuestre su correccion con respecto al plegado de constantes, es decir, demuestre que para cualquier expresion e se cumple que
                    \begin{center}
                        $eval s e = eval s (cfold e)$
                    \end{center}

                \begin{lstlisting}[language=Haskell]
                
                    eval :: EVar -> EAs -> Integer
                    eval s (x) = s x  
                    eval s (n) = n    
                    eval s (e1 + e2) = eval s e1 + eval s e2 
                    eval s (-e) = -eval s e                 
                    eval s (e1 * e2) = eval s e1 * eval s e2
                    
                \end{lstlisting}    
                Ahora demostramos la corrección del intérprete con respecto al plegado de constantes.\\

                \textbf{Demostración:} Induccion estructural sobre la expresión e.\\
                
                \textbf{Casos Base:}
                \begin{itemize}
                \item Si $e$ es una variable $x$, en ambos lados de la expresión son iguales, en $eval$ $s$ $e$ devuelve el valor esperado x, así como en $eval$ $s$ ($cfold$ $e$) tambien devuelve $x$, ya que $cfold$ no hace ninguna simplificación. Por lo tanto $eval$ $s$ $e$ = $eval$ $s$ ($cfold$ $e$).\\

                \item Si $e$ es una constante $n$, asi como en el caso anterior ambas partes serán iguales, debido a que $cfold$ no altera constantes, por lo que en ambos lados devuelve $n$, entonces $eval$ $s$ $e$ = $eval$ $s$ ($cfold$ $e$).\\
                \end{itemize}

                \textbf{Hipótesis de Inducción(H.I.)}: Para una expresión $e$ arbitraria y estado $s$, se cumple que $eval$ $s$ $e$ = $eval$ $s$ ($cfold$ $e$).\\

                \textbf{Paso Inductivo:}
                \begin{itemize}
                    \item Suma($+$): Supongamos que se cumple la H.I. para $e1$ y $e2$, esto es $eval$ $s$ $e1$ = $eval$ $s$ ($cfold$ $e1$) y $eval$ $s$ $e2$ = $eval$ $s$ ($cfold$ $e2$).Consideremos $e$ = $e1 + e2$, para este caso $eval$ $s$ ($e1$ + $e2$) realiza la suma de los valores $e1$ y $e2$ que seria $eval$ $s$ $e1$ + $eval$ $s$ $e2$.Por lo que se tiene $eval$ $s$ ($e1$ + $e2$) = $eval$ $s$ $e1$ + $eval$ $s$ $e2$.Hacemos los mismo para $eval$ $s$ ($cfold$ $e1$ + $cfold$ $e2$), e cual realiza la suma de los valores $cfold$ $e1$ y $cfold$ $e2$ que sería $eval$ $s$ ($cfold$ $e1$) + $eval$ $s$ ($cfold$ $e2$). Por H.I. tenemos que $eval$ $s$ ($cfold$ $e1$) = $eval$ $s$ $e1$, a su vez tambien se tiene que $eval$ $s$ ($cfold$ $e2$) = $eval$ $s$ $e2$. Por lo tanto $eval$ $s$ ($cfold$ $e1$ + $cfold$ $e2$) = $eval$ $s$ $e1$ + $eval$ $s$ $e2$.Se demuestra que $eval$ $s$ ($e1$ + $e2$) = $eval$ $s$ ($cfold$ $e1$ + $cfold$ $e2$).\\

                    \item Multiplicación($*$): Analogamente al caso de la suma, supongamos que se cumple la H.I. para $e1$ y $e2$, esto es $eval$ $s$ $e1$ = $eval$ $s$ ($cfold$ $e1$) y $eval$ $s$ $e2$ = $eval$ $s$ ($cfold$ $e2$).Consideremos $e$ = $e1$ $*$ $e2$, para este caso $eval$ $s$ ($e1$ $*$ $e2$) realiza el producto de los valores $e1$ y $e2$ que seria $eval$ $s$ $e1$ $*$ $eval$ $s$ $e2$.Por lo que se tiene $eval$ $s$ ($e1$ $*$ $e2$) = $eval$ $s$ $e1$ + $eval$ $s$ $e2$.Hacemos los mismo para $eval$ $s$ ($cfold$ $e1$ + $cfold$ $e2$), el cual realiza el producto de los valores $cfold$ $e1$ y $cfold$ $e2$ que sería $eval$ $s$ ($cfold$ $e1$) $*$ $eval$ $s$ ($cfold$ $e2$). Por H.I. tenemos que $eval$ $s$ ($cfold$ $e1$) = $eval$ $s$ $e1$, a su vez tambien se tiene que $eval$ $s$ ($cfold$ $e2$) = $eval$ $s$ $e2$. Por lo tanto $eval$ $s$ ($cfold$ $e1$ $*$ $cfold$ $e2$) = $eval$ $s$ $e1$ + $eval$ $s$ $e2$.Se demuestra que $eval$ $s$ ($e1$ + $e2$) = $eval$ $s$ ($cfold$ $e1$ + $cfold$ $e2$)y entonces $eval$ $s$ $e$ = $eval$ $s$ ($cfold$ $e$).\\

                    \item Negación($-$): Supongamos que se cumple la H.I. para $e$, entonces se tiene que eval s e = eval s (cfold e).Consideremos  $e$ = $-e$, para este caso $eval$ $s$ ($-e$) realiza la negación del valor $e$ que seria $-eval$ $s$ $e$.Por lo que se tiene $eval$ $s$ ($-e$) = $-eval$ $s$ $e$. Hacemos lo mismo para $eval$ $s$ ($-cfold$ $e$) el cual realiza la negación del valor $cfold$ $e$ que sería $-eval$ $s$ ($cfold$ $e$). Por H.I. tenemos que $eval$ $s$ ($cfold$ $e$) = $eval$ $s$ $e$.Por lo tanto $eval$ $s$ ($-cfold$ $e$) = $-eval$ $s$ $e$. Se demuestra que $eval$ $s$ ($-e$) = $eval$ $s$ ($-cfold$ $e$).\\
                \end{itemize}
                Por lo tanto, para cualquier expresion $e$ se cumple que $eval$ $s$ $e$ = $eval$ $s$ ($cfold$ $e$) en el lenguaje EAs.\\

            \end{itemize}

        \item[4.] A continuacion se define la sintaxis concreta de un lenguaje funcional muy simple.
            \begin{center}
                $e ::= x | n | e1 e2 | fun (x) \rightarrow e$
            \end{center}

        En donde el primer constructor representa las variables del lenguaje, el segundo numeros naturales, el tercero aplicacion de funcion y el ultimo la definicion de funciones.
            \begin{itemize}
                \item[a)] Traduce la gramatica anterior a una definicion inductiva con reglas de inferencia.
                \item[b)] Disena una sintaxis abstracta apropiada para este lenguaje.
                Hint: Primero observa si es necesario alguna especie de ligado como el que define el operador let visto en clase.
                \item[c)] Escribe las reglas para la relacion de analisis sintactico $(\leftarrow\rightarrow)$ del lenguaje.
                \item[d)] Disena un algoritmo de sustitucion para este lenguaje.
                \item[e)] La relacion de $\alpha$-equivalencia en este lenguaje se da respecto al operador de definicion de funcion fun, se dice que dos expresiones son $\alpha$-equivalentes si solo difieren en el nombre de la variable del parametro de la funcion. Por ejemplo:
                \begin{center}
                    $fun (x) \rightarrow x \equiv\alpha fun (y) \rightarrow y$
                \end{center}
        Demuestra que $\equiv\alpha$ es una relacion de equivalencia.
            \end{itemize}
        \item[5.] Juanito Alimana quiere definir un lenguaje que le permita controlar un robot con movimientos y funcionalidades muy simples. El robot se mueve sobre una cuadricula siguiendo las instrucciones especificadas por el programa. Al inicio el robot se encuentra en a coordenada (0, 0) y viendo hacia el norte. El programa consiste en una secuencia posiblemente vacıa de los comandos move y turn separados por punto y coma, cada comando tiene el siguiente funcionamiento:
            \begin{itemize}
                \item turn hace que el robot de un giro de 90 grados en el sentido de las manecillas del reloj.
                \item move provoca que el robot avance una casilla en la direccion hacıa la que esta viendo.
            \end{itemize}
            Un ejemplo de un programa valido es:
            \begin{center}
                move;turn;move;turn;turn;turn;move
            \end{center}

            Al final del programa el robot termina en la casilla (2, 1). La primera entrada de la coordenada
            indica la posicion vertical mientras que la segunda es la posicion horizontal.\\ 
            Juanito nos pidio definir la semantica operacional de paso pequeno para el lenguaje que controla al robot. Para esto responde las siguientes preguntas formalmente, para disenar un sistema de transicion:
                \begin{itemize}
                    \item[a)] Determina el conjunto de estados.
                    \item[b)] Identifica los estados iniciales y finales del sistema de transicion.
                    \item[c)] Define la funcion de transicion $\rightarrow$R que indique como se debe transitar entre los estados del sistema. De tal forma que defina una semantica operacional de paso pequeno.
                    \item[d)] Muestra paso a paso la ejecucion del programa
                \end{itemize}
                \begin{center}
                    move;turn;move;turn;turn;turn;move
                \end{center}
            usando la relacion $\rightarrow$R y partiendo del estado inicial correspondiente.
    \end{itemize}
\end{document}
